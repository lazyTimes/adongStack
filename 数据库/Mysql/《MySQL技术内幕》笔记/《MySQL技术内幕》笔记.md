# 数据库和数据库实例。
    数据库：是指用特殊的文件形式存储的一种文件类型的集合。本质上还是文件。
    数据库实例：是指数据库由后台进程以及共享存储区组成的一个系统进程。本质上表现为一个系统进程。
    这里需要小心的区分，因为很容易混淆两者的概念，虽然我们的数据是存储在数据库的特殊文件的，但是我们并不能够直接操作数据库的文件，而是要通过数据库的实例，并且使用特殊的数据库实例操作指令对于文件的格式进行改动。

## 案例：
1. 使用`./mysqld_safe&`以及`ps -ef | grep mysqld`查看当前的mysql实例系统进程。

### mysql的读取配置文件实战：
使用命令：`mysql --help | grep my.cnf`
通常的读取顺序如下：
+ /etc/my.cnf
+ /ect/mysql/my.cnf
+ /usr/local/mysql/etc/my.cnf
+ ~./my.cnf


# mysql的体系和结构
重点记忆 1-1的图：在第4页。
Mysql的大致组成部分：
+ 连接池
+ 管理服务和工具组件
+ sql接口组件
+ 查询分析器组件
+ 优化器组件
+ 插件式存储引擎
+ 物理文件

这里特别提一下存储引擎，存储是可以替换的插拔式组件，可以自定义实现。同时存储引擎**基于表但是不是数据**。
## mysql存储引擎的常见分类：
### innodb
介绍：
    设计目标是在线的事务处理（oltp）应用
    mysql目前默认的存储引擎，在建表不指定存储引擎的情况下默认使用innodb，但是需要注意的是真正默认是在**mysql5.5.8**版本之后才是真正的默认，而之前使用的都是旧版本的innodb，并不是真正的mysql innodb。
    还有一个容易混淆的点是innodb plugin
特点：
+ 支持事务
+ 支持行级锁以及外键，同时支持读写分离的锁
+ 5.5.8开始是默认的存储引擎
+ 使用mvcc并发版本控制提高并发性
+ 支持4种事务隔离级别，默认为不可重复读（和其他主流数据库有很大的差别）
+ 默认使用聚集索引作为主键提高查询效率

### myisam存储引擎
在4.1之前是默认的存储引擎，但是使用效果不是很如意
+ 不支持事务
+ 只支持表锁，不支持行级锁
+ 支持全文索引（优势）
+ 存储引擎表由myd和myi组成，myd存数据文件，myi存索引文件
+ 支持工具mysampack进行表压缩，但是恢复速度慢同时容易损坏

> mysql5.0之前只支持4gb的大小
myisam存储引擎种，mysql**只**缓存索引文件其他由系统操作完成

### ndb
介绍
索尼公司收购得到的一款存储引擎，结构使用了share nothing的集群架构，具备高可用的特点
特点：
+ 数据全部放在内存中操作
+ mysl5.1可以将非索引放磁盘
缺点：
+ 连接操作在数据区完成而不是存储引擎区完成，连接会产生大量的网络开销

### memory存储引擎
介绍：
    将表的数据全部放到内存操作，数据库崩溃或者重启则数据全部情况，适合数据存储的临时表，同时innodb的产生临时表的操作就是产生memory表
特点
+ 速度十分快
+ 只支持表锁，不支持text和blob
+ 用定长的字符存储变长的数据（这也是为什么字段要设置的刚好合适）

### archive引擎
介绍：面向高速插入和压缩的一款存储引擎
特点：
+ 只支持insert和select操作
+ mysql5.1开始支持索引
+ 使用zlib进行压缩存储
+ 适合存储归档数据
+ 不提供事务安全操作

### federated
介绍：不存放数据而是利用句柄只想一个mysql的远程服务器上
特点：
+ 只支持mysql数据库表，不支持异构数据库表

### maria存储引擎：
介绍：替代myisam存储引擎作为默认存储引擎的存在。
特点：
+ 原版人马开发的升级版本
+ 提供mvcc和行锁的功能
+ 具备myisam的特点
+ 支持事务和事务安全选项
+ 更好的blob字段

## 存储器的比较
查看第10页的表，很重要的一张表

## 如何查看当前的存储引擎？
`show engines`命令进行查看

# mysql连接：
## 1. tcp/ip连接，鉴权
在连接之前，会进行类似下面的检查操作：
`select host,user,password from user`默认的系统用户表查找当前的用户权限，同时查看当前的用户是否存在指定的权限，如果不符合权限的要求，会禁止连接或者禁止部分操作。
        
## 2. 命名管道共享内存
mysql4.1之后提供了共享内存的连接方式

## 3. unix套接字
用户可以在配置文件中指定文件套接字路径，比如--socket=/temp/mysql.sock
启动时候会根据配置的套接字路径查找，然后就可以根据套接字连接了

# InnoDB存储引擎
## Innodb存储引擎概述
### 简介
innodb最早是一个第三方引擎，由innobase oy公司开发。包括mysql在内的所有二进制发行版本，从mysql5.5开始作为默认存储引擎。
需要注意的是很多人用的mysql5.1的innodb都是老innodb，并且被称为innodb plugin，这和innodb 1.x.x的版本不一样。

### 特点：
1. 第一个完整支持acid的存储引擎
2. 支持行锁/MVCC（并发版本控制）/支持外键和一致性非锁定读
3. 最有效的利用内存和CPU
4. mysql的亿万数据写入大概是800次每秒

### 体系架构
多后台线程的体系，同时每一个线程通常负责一项重要的内容比如重做日志缓存，缓冲池线程等等。

### 后台线程
master thread：核心的后台线程，主要负责缓冲池的数据异步刷新，保证数据一致性等操作。
下面来看下不同版本的master thread线程的工作内容以及变化
#### 1.0.X之前的版本
设计的理念有点儿类似于状态模式，在不同的模式下做不同的判断和操作
特点：
1. 具备最高的优先级，内部由多个循环组成：主循环，后台循环，刷新循环，暂停循环
2. 根据运行状态：Loop， background loop，flush loop和 suspend loop进行切换（关键）

loop：
主要是通过thread。sleep的操作完成和实现的，比如每10秒执行一次操作，但是不精确
每秒一次的操作：
+ 日志缓存刷新到磁盘
+ 合并插入缓存（可能）
+ 最多100个缓冲池脏页刷新
+ 如果没有用户活动，切换到background loop

每十秒一次操作：
innodb 会判断10秒内到io次数是否小于200次，如果是证明io资存在空闲，并且会执行脏页刷新到操作
如果可以执行full purge到操作，则根据当前实际的操作尝试至多20个的undo页回收。
+ 刷新100个脏页到磁盘
    + 需要参考值：buf_get_modified_ratio_pct当中的：innodb_max_dirty_pages_pct 比例，默认为90%，后面改为75%
+ 合并至多5个插入缓冲（总是）
+ 将日志缓冲刷新到磁盘（总是）
+ 删除无用undo页
    + 最多尝试回收20个Undo页
+ 刷新100个或者10个脏页到磁盘
    + 如果比例超过70%，则刷新100个脏页
    + 如果比例小于70%，则刷新10个脏页

background loop:
会进行如下操作：
+ 删除无用的undo页
+ 合并20个插入缓冲
+ 跳回主循环
+ 不断刷新100个页直到符合条件

## 分析问题：
### undo回收和合并插入缓冲
    通过上一节的分析可以看到在删除Undo操作和刷新插入缓冲的时候，数量未免过少了，这里明显是对于io进行了限制，因为设计之初的硬件资源是很吃紧的，同时硬盘的容量小不说还十分昂贵，但是可以发现现代固态动辄上t，明显限制了性能的发展。
    为了解决这个问题inndb plugin 提供了一个参数：innodb_io_capacity：
    规则如下：
    + 合并插入缓冲的时候，合并的数量为该值的5%，比如如果设置200则5%为10
    + 缓冲区刷新脏页的时候，刷新数量为innodb_io_capacity这个值。

### innodb_max_dirty_pages_pct默认值问题
    在innodb 1.0.x之前都为90%，脏页占缓冲池的90%，未免过大了一些。因为如果内存过大会导致刷新脏页引发系统暂停的时间更长，所以后来官方修复后改为75%

### innodb_adaptive_flushing问题：
    每秒刷新的数量问题，小于innodb_max_dirty_pct 的时候不刷新，但是大于反而会进行刷新100个脏页的操作。
    解决方案是通过：buf_flush_get_desired_flush_rate的函数判断产生重做日志的速度来决定刷新脏页的数量。这个算法比较有意思，是一种类似于效率选值的手段，所以这里并不是完全的if/else的判定，小于innodb_max_dirty_pct的时候也会刷新一定量的脏页回磁盘
    
## 查看当前master thread 的状态信息。
`show engine innodb status\G`
## innodb 1.2.x之后的master thread
1. 对于线程进行优化，将每10秒操作和刷新脏页的操作， 分离为一个page cleaner thread
2. 分离了一个undo页清理的单独线程减轻master thread的操作。


## iothread 
innodb使用大量的aio提高操作性能在1.0版本之前有4个io，write, read, insert buffer 和 log io thread,在1.0.x版本当中read和write增大到4个使用readinnodb_file_io_threads 参数和 innodb_write_io_threads 参数。
### 如何查看io threads?
`show engine innodb status\G`

## Purge thread
这个主要是用于清除undo页使用，在1.1到版本之后可以单独的线程进行，减轻master thread的压力，线程只有一个，虽然可以通过参数设置但是mysql回根据相应的警告并且不允许设置。

## page cleaner thead
主要用于1.2.x之后的脏页回收线程，脏页刷新的操作放到单独的线程完成。

## 内存
### 缓冲池
innodb 基于磁盘存储数据，使用磁盘进行数据操作和cpu确实相差十万八千里。
innodb引入的缓冲池就是为了解决这个问题用到。

大致的工作原理：
1. 将磁盘的数据fix到磁盘当中
2. 下次操作判断是否在缓冲池中有相同的页
3. 如果有则返回缓冲池，没有就查询磁盘。

这时候会发现，如果缓冲池发生了改动，意味着此时的页已经"脏"了，所以被称之为脏页，而脏页需要刷新回磁盘中进行持久化。
这里同时使用了一种叫做 **check point**的操作机制刷新回磁盘并且提高整体的性能。

### 缓冲池刷新的大致数据类型
重点：缓冲池只缓冲索引页不缓冲数据页这种说法过于笼统
+ 索引页
+ 数据页
+ undo页
+ 插入缓冲
+ 自适应索引
+ innodb的锁信息
+ 数据字典类型。

如何开启多个缓冲实例：
innodb_Buffer_pool_instances 设置为2.代表数据库用户有两个缓冲池的实例。

### 缓冲池如何管理
#### lru list/free list/flush list
##### lru list
lru最少使用算法管理：
    最频繁的页在最前端，最少使用的页在最后端。当不能存放新的页时候，优先释放lru尾端的页。
    
innodb存储引擎默认的大小为16kb.需要注意的是lru使用的算法并不是传统的头部插入队列，而是使用一个midpoint，当新页进来是插入到midpoint的位置。大概在lru列表的5/8的位置。
使用`show variables like 'innodb_old_blocks_pct'\G`的形式。
同时根据midpoint来划分old和new，也就是热点数据和非热点数据。

???为什么使用midpoint的位置???
因为我们常见的操作都是查询操作，这一类操作的缓存很可能因为数据变动失效，而真正需要缓存的是插入，更新这一类操作，所以为了减少对于磁盘的访问，使用midpoint更加符合日常的操作频率。

???那么访问多少次尾端数据更新到热端呢???
通常会在访问inodb_old_blocs_time = 1000的设置下访问多少次将冷端数据放到热端。如果有很多热端数据，可以将这个值大幅度缩小。

##### free list:
默认启动的实际lru list是空的，数据页基本都放在free list。

freelist都运行流程：
1. 当出现数据页访问，将freelist的数据页删除，放入到lru list当中
2. 如果lru list中没有满，则插入到midpoint的位置，如果已经满了则需要移出尾端的数据，然后空出内存给新的数据页使用
3. 当old区域转到new的区域，则发生了made young。

> 可以使用：`show engine innodb status`的指令来观察free 列表的运行状态
：todo 需要画图同时解释运行结果的参数。

> 提示：free list 1.2.x的变化:可以使用 innodb_buffer_pool_stats 这张表观察缓存池的运行状态。

innodb_buffer_page_lru 观察lru每个页的具体信息。

lru列表的压缩页功能：
支持版本：1.0.x版本之后。
查看命令：`show engine innodb status\G`
注意事项：
注意lru的页包含了unzip_lru列表的页

unzip_lru是如何分配内存的：
首先，对于不同压缩页大小进行分别管理，其次使用**伙伴算法**进内存分配：
例如申请4kb大小：
+ 检查4kb的unzip_lru列表，检查是否可用空闲页
+ 如果有直接使用
+ 否则，检查8kb的unzip_lru列表
+ 如果得到空闲页，分成2个4kb的页，放到4kb的unzip_lru存储
+ 如果得不到空闲页，则来lru列表申请一个16kb的页，按照8:4:4的比例放到unzip_lru列表中

###### 脏页：
当lru列表被修改之后，该页是脏页，此时缓冲池和磁盘的数据不同步。如何同步呢?之前说过使用checkpoint的机制。

脏页存放在哪里
**flush列表**中的页被称为脏页

脏页注意事项：
注意脏页其实是存放在**lru list**当中的，所以也可以使用相关的lru查询指令进行查询，书中现实的modified就是脏页的数量，同时要注意查询的时候需要加入查询参数：`where oldest_modification > 0`的条件。



### 重做日志缓冲
#### 什么是重做日志缓冲？
innodb为了做日志归档，保护历史数据，使用重做日志缓冲来解决日志跟不上搜索引擎搜索的问题。

#### 设计规则
    重做日志缓冲池一般存放重做日志，当然不需要设置的很大，会以一定的频率刷新到重做的日志文件。
    
重做日志缓冲的大小设置：`innodb_log_buffer_size` 这个配置参数。

#### 什么时候回刷新日志文件到磁盘
- master thread 每一秒刷新一次到重做日志文件
- 事务提交会刷新重做日志缓冲到磁盘
- 剩余空间小于1/2的时候

## checkpoint 技术
    上文说过checkpoint的主要作用是为了进行脏页的刷新和同步，如果一条dml语句改动了记录的内容，此时改动的是缓冲池内容实际上磁盘数据并没有改变，而innodb会根据checkpoint机制对于数据继续修改。
    






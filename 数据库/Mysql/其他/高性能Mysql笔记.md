# 高性能mysql

## mysql逻辑架构图

![mysql架构图](D:\java\自学笔记\个人总结\2018.11\mysql\mysql架构图.png)

> **小贴士：**
>
> 存储引擎不会去解析sql, 不同存储引擎不会相互通信，只是简单响应上层请求（**InnoDB引擎除外，会解析外键定义，因为mysql服务器本身没有实现该功能**）

## 连接管理和安全性

每一个连接都是一个单独线程，服务器会对连接缓存而不是创建或者销毁线程

## 优化与执行

执行流程：

1. 解析查询
2. 创建数据结构（解析树），优化（重写查询，读表顺序优化，选择索引等）
3. 尝试查询缓存（SELECT）
4. 返回结果

## 并发控制

内部拥有锁机制防止数据破坏

### 共享锁和排他锁（读锁和写锁）

+ 读锁是共享的，相互不阻塞
+ 写锁是排他的，一个写锁会阻止其他读锁和写锁

### 锁粒度

提高共享资源并发性就是让锁更有选择性，让锁只监控部分数据

记住：**任何时候，给定资源下，锁定数据量越少，并发程度越高，只要相互不发生冲突即可**

mysql提供多个存储引擎支持丰富的锁策略

#### 表锁 (table lock)

msyql中最基本的锁策略，开销最小的策略

类似邮箱的加锁机制：会锁定整张表，用户访问时候，对表进行写操作，需要优先获得写锁，会阻塞其他用户读写操作，**只有没有写锁时候，其他用户才能获得读锁**，读锁之间是不相互阻塞的

特定场景表锁可以有良好性能

注意事项：

1. **写锁**比**读锁**有**更高的优先级**，写锁有可能会插入到一个读锁的前面，但是读锁不能插入到写锁队列前面
2. 服务器会为alter table 等语句默认使用表锁而不是根据引擎决定

#### 行级锁 (row lock)

该锁可以**最大程度支持**并发处理（与此同时带来巨大锁开销）

**InnoDB**和**XtraDB**， 实现了行级锁

##### 行级锁只在存储层实现，而<font color='red'>mysql服务层没有实现</font>

## 事物

### 事物的ACID

+ A（atomicity） 原子性
  + 一个事务是一个不可分割的单位，事务中的所有操作，要么全完成，要么全不完成，任何一个操作的失败，都会回滚到事务执行之前的状态。
+ C （consistency） 一致性
  + 事务结束后，系统状态是一致的。即，在并发操作时，系统的状态也要和串行执行事务时一样。
+ I  （isolation）隔离性
  + 并发执行的事务之间，无法看到彼此的系统状态。
+ D （durability）持续性
  + 在事务完成后，事务对数据库的操作会被持久保存在数据库中，不会被回滚。

事物使用与否根据实际业务情况而定（甚至可以不使用事务，而是使用sql 进行一定的安全措施）

#### 如何选择合适的 mysql 引擎来解决问题可能事务本身更加重要

## 隔离级别

![](D:\java\自学笔记\个人总结\2018.11\mysql\隔离级别.png)



## 死锁

如果多个线程同时更改同一行数据，你们两个线程互相等待对面的锁，造成死锁

### 解决方法：

 	1. 例如:InnoDB 检测死循环依赖，并且立即返回一个错误（死锁会造成慢查询）
 	2. 查询时间达到锁等待超时设定时间之后放弃锁清秋
 	3. InnoDB目前处理方法：**将持有<font color='red'>最少行级排他锁</font>的事务进行回滚**
 	4. 大多数时候因为数据冲突，有时候确实是因为存储引擎方式引起！！！

> 只有部分或者完全回滚一个事务才能打破死锁，事务性系统无法避免。
>
> **大多数时候只需要重新执行死锁事务即可**



## 事务日志

事务日志采用追加方式,因此I/O的消耗比较小，内存修改数据后台慢慢刷会磁盘，目前大多数存储引擎都是这样实现被称为：**预写式日志**

## mysql中的事务

+ innoDB 
+ NDB cluster

### 自动提交

![](D:\java\自学笔记\个人总结\2018.11\mysql\mysql事务-自动提交.png)

#### <font color='red'>切记查找对应版本会产生 AUTO_COMMIT 所有语句</font>

### 设置隔离级别

`> SET SESSION TRASACTION ISOLATTION LEVEL READ COMMITTED`

mysql 可以识别 4 个 ansi 隔离级别,innodb 引擎也支持

### 混合使用存储引擎

mysql 服务层不管理事务，事务下层存储引擎实现，同一个事务使用多种存储引擎不可靠

**mysql 对非事务型表不会有提示！！！！**

**mysql 对非事务型表不会有提示！！！！**

**mysql 对非事务型表不会有提示！！！！**

### 隐藏和显式锁定

INNODB 使用两阶段锁定协议，锁只有在执行提交或者回滚才会释放

INNODB 会根据隔离级别自动加锁

innodb支持显示的枷锁

`SELECT ... FROM IN SHARE MODE`

`SELECT ... FOR UPDATE`

> 注意：这不是sql规范

mysql lock 和 unlock tables 语句和存储引擎无关，而是在**<font color='red'>服务层</font>**实现

**不能用来替代事务性存储引擎**,有其他用途

> 建议：除了事务中禁用autocommit ,可以使用lock tables 之外，其他任何时候不要显式执行 lock tables,不管是什么存储引擎



## 多版本并发控制（mvcc）

mvcc实现：保存数据在某个时间点的快照实现

记住：根据事务开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的

引申：**悲观锁**和**乐观锁**

### innodb 的 mvvc

实现原理：通过在每行记录后面保存两个隐藏的列实现

+ 一个列保存行创建时间
+ 另一个保存过期时间（删除时间）

事务开始时候系统版本号（每个新事务都会递增版本号）作为事务版本号，和查询到记录的版本号比较



#### REPEATABLE READ 隔离级别操作

![](D:\java\自学笔记\个人总结\2018.11\mysql\READ隔离级别事务.png)



MVCC 只在 **REPEATABLE READ** 和 **READ COMMITTED**  两个隔离级别工作

## mysql 存储引擎

+ 建表时候，会在mytable.frm 中定义表定义

+ 表的定义是在**服务层**
+ 不同系统存储形式不一样（数据和索引）

#### 使用`show table status`命令 显示表的相关信息

例如 `show table status like 'user' \G`

### <font color='red'>mysql5.1</font>中的innodb plugin 支持一些新特性（BLOB存储方式使用）

#### mysql5.1一定要使用 innodb plugin ，比 旧innodb要好得多

> mysql 5.5 之后 innodb plugin 才替换掉旧的 Innodb

## Innodb 概览

**mysql4.1** 之后

+ innodb 可以将每个表的数据和索引放在单独文件当中
+ innodb 可以将裸设备作为存储介质

### 特点

+ 使用mvcc 支持高并发
+ 实现了四个标准隔离级别（默认级别为 **REPEATABLE READ**(可重复读)）
+ 使用间隙锁(next-key locking) 策略防止幻读的出现
+ 间隙锁不仅锁定查询行，还对索引进行锁定
+ INNODB 基于 **聚簇索引** 建立
+ 存储格式是平台独立的，意味着可以跨平台使用
+ 内部进行优化，**可预测性预读**，可以自动在**内存**当中**创建hash索引**加速读操作**自适应哈希索引**，加速操作的加入缓冲区
+ <font color='red'>阅读官方文档"InnoDB 事务模型和锁"</font>了解更多内容
+ innodb 通过一些机制和工具实现真正的**热备份**

> 聚簇索引 对于主键查询有非常高的性能，不过二级索引中必须包含主键列，
>
> **如果主键列很大，其他所有索引都会很大**，

## myiSAM 存储引擎

mysql5.1 之前默认使用 MyISAM 作为存储引擎

### 特点：

+ 全文索引，压缩，空间函数
+ **不支持事务和行级锁**
+ 崩溃之后无法安全恢复

### 存储：

将表存储在两个文件当中

+ 数据文件 ( .MYD )
+ 索引文件 ( .MYI )
+ 表支持包含动态或者静态（长度固定）行，mysql根据表定义决定存储形式
+ Mysql 5 当中，如果是变长行，只能处理256TB 数据
+ 修改Myisam 表指针长度， 修改表 max_rows 和 avg_row_length 选项实现

### myisam特性

+ 加锁与并发：对整张表加锁，而不是针对行
+ myisam 表, mysql 可以手工或者自动检查和修复操作（但是效率较低）
+ 索引特性：即使是BLOB 和 TEXT等长字段,也可以基于500 个字符创建
+ myisam 支持全文索引，基于分词创建索引
+ 延迟更新索引键

### myisam 压缩表

如果表中数据不再修改，可以使用myisam 压缩表

减少磁盘i/o, 提高查询性能

### myisam 性能

最典型的性能问题是 表锁 的问题

## mysql 内建其他存储引擎

1. Archive 引擎
   1. 只支持 insert 和 sleect, mysql5.1 之前不支持索引
   2. 适合日志和数据采集类应用
   3. 支持行级锁和专用缓冲区，实现高并发插入
   4. 不是事务性引擎，只对告诉插入和压缩做了优化的简单引擎
2.  Blackhole 引擎
   1. 无存储，丢弃所有插入数据。但是服务器会记录blackhole 表的日志
   2. 简单的日志引擎
3. **CVS 引擎**
   1. 将普通cvs 作为mysql 表处理，**不支持索引**
   2. cvs 引擎可以作为 数据交换的机制（excel 表格的转换）
4. Federated 引擎
   1. 访问其他mysql 服务器代理，但是默认是**禁用**的
5. **Memory引擎**
   1. 可以快速访问数据 使用 Memory  表
   2. 所有数据都是在内存当中
   3. 每行长度固定
   4. 并发性能较低
   5. 作用：
      1. 查找或者映射表
      2. 缓存周期性聚合数据
      3. 保存数据产生的中间数据
   6. 如果mysql 查询使用临时表保存结果，你们内部使用就是Memory 表，但是如果数据量较大，就会转为myisam 表
6. Merga 引擎
   1. myisam 引擎变种，多个myisam 表合并变种
   2. 分区功能实现后，被放弃
7. **NDB 集群引擎**
   1. 用于mysql 集群

## 第三方存储引擎

1. OLTP 类引擎

   1. XtraDB引擎
   2. PBXT引擎
   3. TokuDB 引擎

   ## 选择引擎

   除非使用到了innodb 不具备的特性，并且无法替代，否则优先选择innodb

   主要看待四点

   1. 事务
   2. 备份
   3. 崩溃恢复
   4. 特有特性

   个人看法：

   1. 对于极高的插入数据要求时候，可以使用myisam 或者archieve
   2. 读多写少的业务可以考虑

   > 测试崩溃数据恢复问题就是模拟电源断电！！！

   ## 转换数据表引擎

   ### 1. 直接转换

   `mysql> ALTER TABLE mytable ENGINE = InnoDB`

   这种方式性能很低，而且会加锁

   ### 2. 使用导入导出的方法

   #### 导入与导出

   使用msyql 工具导出sql 语句然后手动修改引擎

   ### 3. 创建与查询

   ```
   mysql > create table innodb_table like myisam table;
   mysql > alter table innodb_table engine = InnoDB;
   mysql > insert into innodb_table select * from myisam_table
   ```

   #### 数据量很大的话可以分批处理

   ```
   start transaction;
   insert into innodb_table select * from myisam_table 
   where id between x and y;
   
   insert into innodb_table select * from myisam_table 
   where id between x and y;
   
   insert into innodb_table select * from myisam_table 
   where id between x and y;
   
   .......
   
   commit
   ```


## mysql 时间线

![](D:\java\自学笔记\个人总结\2018.11\mysql\mysql 只读测试.png)



# 基准测试

## 为什么需要基准测试

![](D:\java\自学笔记\个人总结\2018.11\mysql\为什么需要基准测试.png)



## 基准测试策略

+ 基于mysql 单独测试 - 单组件式
+ 对整个系统整体测试 - 集成式

使用整个系统测试原因主要如下

![](D:\java\自学笔记\个人总结\2018.11\mysql\系统基准测试原因.png)

如果不需要关注整体应用，只关注msyql 性能

![](D:\java\自学笔记\个人总结\2018.11\mysql\msyql基准测试原因.png)



## 测试指标

+ 吞吐量
+ 响应时间或者延迟
+ 并发性
+ 可扩展性

### 应当避免以下情况再进行基准测试

![](D:\java\自学笔记\个人总结\2018.11\mysql\基准测试方法.png)

## 获取系统性能和状态

![](D:\java\自学笔记\个人总结\2018.11\mysql\Mysql基准测试脚本.png)

## 获取基准测试结果

## 运行基准测试并分析结果

使用 shell , php, perl 都可以实现

![](D:\java\自学笔记\个人总结\2018.11\mysql\基准测试脚本2.png)

### 绘图

`gnuplot > plot "qps-per-5-seconds" using 5 w lines title "qps"`

![绘图](D:\java\自学笔记\个人总结\2018.11\mysql\绘图.png)

## 基准测试工具

+ apach AB
+ http_load
+ jmeter

## 单组件式测试工具

+ mysqlslap 

  + 包含在mysql5.1 的发行包当中，会自动生成查询schema的select 语句

+ mysql benchmark suite (sql-bench)

  + 优点：单线程，测试服务器执行查询的速度。
  + 有大量预定义的测试
  + 缺点：单用户模式，测试数据集很小而且无法指定数据
  + 无法测试多cpu能力

+ super mack 

  + 用于 mysql 和 postgresql 基准测试工具

+ database test suite 

  + 类似工业标准的测试工具
  + dbt2 免费的toc-c oltp 测试工具

+ percona's tpcc-mysql tool

  + mysql 高性能并发作者自己制作

+ sysbench 

  + 多线程系统压测工具
  + 支持lua 语言


### msyql 的 benchmark() 函数

Mysql 内置，可以测试某些特定操作的执行速度

方便的测试某些特定操作性能，比如md5() 比 sha1() 函数快

![](D:\java\自学笔记\个人总结\2018.11\mysql\md5()和sha1()函数比较.png)



## 基准测试案例

<font color='red'>重点熟悉 sysbench 测试 ，因为和mysql 自身的设计最为贴合</font>

## 

# 服务器性能剖析

## 性能优化简介

一句话概括：性能即响应时间

### 原则

1. 一定的工作负载之下尽可能的降低响应时间
2. 无法测量就无法有效优化

### 忌讳

1. 错误的时间启动和停止测量
2. 测量的是聚合后的信息，而不是目标活动本身

完成一项任务可以分成两部分

1. 执行时间：优化通过测量定位不同的子任务花费的时间，优化一些子任务，降低子任务的执行效率或者提升
2. 等待时间

> 如何判断测量是正确的
>
> 测量到底有多么不准确，记住一点，使用的测量数据而不是实际数据，测量数据也有多种表现。很容易推导出**错误的结论**

## 性能剖析进行优化

人物结束时间减去启动时间得到响应时间

### 性能剖析两种类型

1. 基于时间分析
   1. 某时候执行时间就是在**等待**
   2. 比如i/o或者查询等待时间过久
2. 基于等待分析

## 理解性能剖析

将最重要的人物展示在前面，但是没有显示的信息也很重要

### 值得优化的查询

 	1. 一些只占总响应时间比重很小的查询不值得优化
 	2. 如果优化成本大于收益，要停止优化！

### 异常情况

​	某些人物没有性能剖析输出也要优化，比如某些人物执行次数很少，但每次都很慢

#### 未知的未知	

​	好的剖析工具尽可能显示“丢失的时间”

​	丢失的时间： 任务的总时间和实际测量时间时间的差

#### 被掩藏的细节

平均值不能完全相信和作为根据

### 应用程序的性能剖析

对于**任何**需要消耗时间的人物都可以进行性能分析

### 实用软件： New Relic

## 捕获查询到日志文件当中

+ mysql 5.0 之前， 慢查询日志的响应时间是秒
+ mysql 5.1 之后，慢查询被加强，可以做到微秒级别的查询

慢查询日志是进度最高测量查询的日志，开销几乎可以忽略不计，但是会消耗大量磁盘空间，

### percona server 慢查询日志

+ 通过--processlist 选项不断查看 show full processlist 的输出
+ 通过抓取 tcp 网络包，根据mysql 客户端 /服务端 通信协议进行剖析

## 建议： 在服务器上使用慢查询日志捕获所有的查询

应该首先生成一个剖析报告，在进行慢查询

![](D:\java\自学笔记\个人总结\2018.11\mysql\慢查询日志.png)

## 剖析报告

![](D:\java\自学笔记\个人总结\2018.11\mysql\剖析报告.png)

## 剖析单条查询

### 1. 使用 show profile

mysql 5.1 之后版本引入，默认是禁用的，但是可以通过服务器变量在连接中动态更改

`mysql> set profiling = 1`

开启后会测量查询执行相关操作的状态

可能被 performance scheema 取代

该工具会讲剖析信息做成一张临时表

示例

1. 执行下列语句

![剖析结果](D:\java\自学笔记\个人总结\2018.11\mysql\show_profile剖析.png)

2. 返回997行数据

![](D:\java\自学笔记\个人总结\2018.11\mysql\show_profile结果.png)

3. 继续看待下面输出

4. 如果不使用上面方法，则使用下列方法

![](D:\java\自学笔记\个人总结\2018.11\mysql\Infomation_schema.png)

### 2. 使用 show status

该命令返回了一些计数器，既有 服务器界别全局计数器，也有基于某个连接的会话级别计数器

show global status 可以查询服务器启动时候开计算查询次数的统计

**全局计数器也会出现在show status**

猜测操作代价或者消耗时间较多的，可以使用**句柄计数器， 临时文件和表计算器**

示例

![](D:\java\自学笔记\个人总结\2018.11\mysql\show_status.png)

### 3. 使用慢查询日志（重点）

通过 **pt_query_digest** 发现“坏查询”

`# query 1 :0 ops, 0x concurrency, ID oxeexxxs at byte 3214 ___`

使用下面方法查看详情

`tail -c +3214 /path/to/query.log` | head -n100

### 4. 使用performance Schema 

**mysql 5.5** 之后新增还不支持查询级别的剖析信息

#### 下面是显示系统等待主要原因的查询：

![系统等待主要原因](D:\java\自学笔记\个人总结\2018.11\mysql\系统等待主要原因.png)

## 诊断间歇性问题

#### 解决间歇性错误案例

![](D:\java\自学笔记\个人总结\2018.11\mysql\解决间歇性错误案例.png)

#### 单条查询问题还是服务器问题？

三种办法：

+ show global status
  + 通过“尖刺”或者“凹陷”来发现问题，这种方法较为简单明了
  + 示例
  + ![](D:\java\自学笔记\个人总结\2018.11\mysql\简单排查1.png)
+ 使用 show processlist
  + 不停的捕获show processlist的输出，查看线程是否有大量处于不正常状态的特征
  + 尾部加入 \G 可以垂直的显示结果
  + 示例
    + ![](D:\java\自学笔记\个人总结\2018.11\mysql\简单排除2.png)

+ 使用慢查询日志
  + 开启方式： 全局级别设置 Long_query_time 为 0，所有连接都采用新设置
  + 替代方案： pt_query_digest 工具
    + 

![](D:\java\自学笔记\个人总结\2018.11\mysql\简单排除3.png)

+ 理解发现的问题
  + 建议先用前两种方法， **show status** 和 **show processlist**

### 诊断器

#### 	pt-map 工具使用

​	![](D:\java\自学笔记\个人总结\2018.11\mysql\pt-map.png)



## 诊断案例

1. 问题是什么： 清晰描述出错误，
2. 为了解决问题做过什么操作

## 其他剖析工具

1. 使用 user_statistics 表

   ![](D:\java\自学笔记\个人总结\2018.11\mysql\其他工具.png)

2. 使用 strace 

![](D:\java\自学笔记\个人总结\2018.11\mysql\其他工具2.png)

## 总结

![](D:\java\自学笔记\个人总结\2018.11\mysql\总结2.png)



# ScHema 与数据类型优化

##  选择优化的数据类型

+ 更小通常更好
  + 尽量使用正确存储数据的最小数据类型
+ 简单就好
  + 使用内建date 类型代替日期字符串
  + 使用整型存储Ip地址
+ 尽量避免Null
+ 通常将列指定为**not null**(尽量)

### 整数类型和实数类型

使用小数点和不使用的区别

### 字符串类型

+ varchar 和 char 的区别
+ blob 和 text的区别
+ blob 和 text 的使用技巧
+ 使用枚举代替字符串类型

### 日期和时间类型

timestamp 使用的存储空间只需要 datatime 的一半

但是时间存储范围却要小

+ datetime : 使用 8个字节；默认以一种无歧义的格式排序显示； 范围 1001 - 9999
+ timestamp ： 使用4个字节； 日期时间戳， 1970年开始，使用from unix ()函数对于日期进行转换；**默认**为**Not null**;并且**无值**的时候**自动根据当前时间插入日期**

### 位数据类型

#### bit:

+ 最大存储64为，使用（位数）指定多少位数据存储
+ 存储方式根据引擎制定
+ mysql 当做字符串处理
+ 尽量避免使用
+ 替代方法： char(0) 保存 null 或者 长度为零 的字符串

#### set:

+ 需要多个true/false时候可以使用

+ 在整数列上按位操作

  + 使用一个8位的tinyint 进行包装替代set

+ 应用：保存访问权限控制表

  + ![](D:\java\自学笔记\个人总结\2018.11\mysql\set数据类型.png)

+ 使用整数可以参考下面例子

  + ![](D:\java\自学笔记\个人总结\2018.11\mysql\set整数存储.png)

  ### 选择标识符

  - 使用整型最佳
  - 字符串类型：
    - **避免使用md5(),sha1(), uuid()产生的字符串会导致insert 以及 slelect 变慢**
    - 使用uuid()应该移除 '-' 值，更好做法使用 unhext()函数转换uuid 为16位的数字，并且存储在binary(16)当中

  ## 特殊数据类型

  对于ip地址，最好使用无符号整数存储，而不是varchar(15)

  inet_aton() 和 inet_ntoa() 函数可以转换

## mysql schema 设计陷阱

1. 过多的列
2. 过多的关联

> **单个查询最好在12个表以内关联！！！！**

3. 全能的枚举

## 缓存表和汇总表

1. 有时候可以使用在同一张表当中保存冗余数据实现
2. 要每一个小时对于网站的数据生成汇总表可以使用一下方式
   1. 每个小时生成一张汇总表
   2. 把前23个完整小时统计表的计数全部加起来
3. 使用不严格的计数或者小范围的查询填满间隙的严格计数都要比计算所有行效率要高

**可以使用影子表来作为替代方案**

## 物化视图

Mysql 不支持原生的 物化视图

使用开源工具  **flexviews** 可以实现

## 加快alter table  速度

技巧：

 	1. 现在一台不提供服务的机器上执行alter table 操作，然后和提供服务的主库进行切换
 	2. 影子拷贝：用要求的表结构创建一张和原表无关的新表，然后使用删表和重命名操作交换两张表，

注意：

1. 所有的Modify  column 操作都会造成表创建

解决：

```
mysql > alter table sakila.fil
	  > alter column rental_duration set default 5;
```

该操作只会修改 .frm 文件

## 只修改.frm 文件

下面的操作可能不会造成重新建表：

1. 移除 一个列的 auto_increment 属性
2. 增加、移除、或者更改一个enum  和 set 常量， 如果移除的是已经有的行数据用到其值的常量，查询会返回空字符串

技巧是为自己想要的表结构创建一个新的.frm 文件，然后用它替换掉已经存在的那张表的 .frm 文件

![](D:\java\自学笔记\个人总结\2018.11\mysql\改动表结构.png)

实例

![](D:\java\自学笔记\个人总结\2018.11\mysql\修改表示例.png)



## 快速创建myiSAM 索引

常用技巧： 禁用索引，载入数据， 重新启用索引

**此办法对于唯一索引无效**

### Innodb 中的类似操作

1. 先删除所有非唯一索引
2. 增加新列
3. 重新创建删掉的索引

### 操作步骤：

+ 用需要的表结构创建一张表，但是不包括索引
+ 载入数据表中以构建 .myd 文件
+ 按照需要的结构创建 另一张空表，这次要包含索引。这会创建需要的 .frm 和 .myi 文件
+ 获取读锁并刷新表
+ 重命名第二种表 .frm 和 .myi 文件。让 Mysql 认为是 第一张表
+ 释放读锁
+ 使用 repair table 来重新创建表的索引。 会根据排序来构建所有的索引，包括唯一索引

## 总结

![](D:\java\自学笔记\个人总结\2018.11\mysql\总结设计原则.png)



# 索引

## B-Tree 索引

即没有特别指明的类型，大多数时候mysql 引擎都支持这种索引（Archive 是例外， 5.1 之前不支持，之后支持单个自增列的索引）

区别：

+ myisam 使用物理位置保存 索引位置，并且对于索引进行了**前缀压缩**
+ innodb 则按照原有数据格式保存数据，并且只要了主键的形式进行索引

内部都是根据存储引擎的实现而有了不同的区别

![](D:\java\自学笔记\个人总结\2018.11\mysql\B-Tree 索引.png)

### 示例

#### 1. 首先创建一张表

![](D:\java\自学笔记\个人总结\2018.11\mysql\B-tree内容.png)

#### 2. 内部存储结构

![](D:\java\自学笔记\个人总结\2018.11\mysql\B-tree内容2.png)

索引对于多个值进行排序的根据是create table 当中定义索引时候的顺序，看一下最后两个条目

#### 下面的查询类型有效

+ 全值匹配
  + 和索引当中所有的列进行匹配
+ 匹配最左前缀
  + 只用索引的第一列
+ 匹配列前缀
  + 匹配某一列值开头的部分
+ 匹配范围值
+ 精确匹配某一列并范围匹配另一列
+ 只访问索引的查询
  + 即只需要访问索引，不需要索引

#### B-Tree 索引的限制：

- 如果不是从最左侧查找无法使用索引
- 不能跳过索引中的列
- 如果查询中有**某个列的范围查询**，则其右边所有的列都无法使用优化查询

## 哈希索引

基于哈希表实现，只有精确匹配索引所有列的查询才有效

### mysql中只有 Memory 引擎支持哈希索引，这样说Memory 表默认的索引类型

#### 限制

+ 哈希索引只包含哈希值和行指针，不存储字段值
+ 哈希索引数据并不是按照索引顺序存储，**无法用于排序*
+ 哈希索引不支持部分索引匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的
+ 哈希只支持等值的比较查询，不支持范围查询
+ 访问哈希数据非常快，哈希冲突的时候需要对于链表进行遍历
+ 哈希冲突高的时候，维护索引操作的代价也很高

#### InnoDB 引擎的自适应哈希索引

当某个索引值频繁使用的时候，会在内存中基于B-Tree 索引创建一个哈希索引

#### 创建自定义哈希索引

在B-Tree 上创建一个伪哈希索引

如下：

1. 创建一个伪哈希索引；但是这样会有很高的查询开销![](D:\java\自学笔记\个人总结\2018.11\mysql\伪哈希索引.png)

2. 使用下面语句可以对于性能的极大提升

   ![](D:\java\自学笔记\个人总结\2018.11\mysql\伪哈希索引2.png)

#### 缺点： 

​	需要手动维护哈希值，可以使用触发器或者手动维护实现

![](D:\java\自学笔记\个人总结\2018.11\mysql\手动维护哈希索引.png)

## 空间索引（R-Tree）

myisam 表支持

## 全文索引

查找文本当中的**关键字**

搜索细节：

1. 停用词
2. 词干
3. 复数
4. 布尔搜索

## 其他索引

### Toku 引擎使用的树索引

。。。。

## 索引的优点

1. 打打减少服务器需要扫描的数据量
2. 帮助服务器避免排序和临时表
3. 将随机I/O转变为顺序I/O

## 高性能索引策略

### 独立的列

#### 前缀索引和索引的选择性

前缀索引可以使索引更小，更快的有效办法

但是mysql 有个缺陷**无法对于前缀索引使用order by 和 group by**,无法使用前缀索引做覆盖扫描

## 多列索引

## 选择合适的索引列顺序

经验法则：

 	1. 将选择性最高的列放在索引的最前列（不一定准确）
 	2. 避免随机的IO和排序

![](D:\java\自学笔记\个人总结\2018.11\mysql\索引经验法则.png)



## 聚簇索引

+ 并不是单独的索引类型，而是数据存储方式
+ InnoDB  实际上在同一个结构中**保存了B-Tree 索引和数据行**
+ 聚簇：数据行和相邻的键值紧凑的存储在一起
+ 一个表只能有一个聚簇索引
+ 数据行实际上是存储在叶子页当中

![](D:\java\自学笔记\个人总结\2018.11\mysql\聚簇索引存储形式.png)

> InnoDB 使用的是主键聚集数据
>
> 图中被索引的列就是主键列

### 聚簇索引优点：

1. 相关数据保存在一起
2. 数据访问更快
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

### 缺点：

1. 最大限度的提高了I/O密集型的性能，但是如果在内存中就无效
2. 插入速度严重依赖插入顺序
3. 更新聚簇索引列代价很高
4. 基**于聚簇索引插入新行**或者**主键被更新**导致需要移动行的时候，可能面临“**页分裂**”
5. 可能导致全表扫描变慢

### myisam 数据分布

![](D:\java\自学笔记\个人总结\2018.11\mysql\myisam数据分布.png)

![主键分布](D:\java\自学笔记\个人总结\2018.11\mysql\myisam主键分布.png)

myisam 主键索引其实就是 primary 的 **唯一非空索引**

### innodb 数据分布

![](D:\java\自学笔记\个人总结\2018.11\mysql\INNODB数据分布.png)

+ **innodb 中聚簇索引“就是“ 表**

+ 二级索引的叶子节点存储的**不是“行指针”**，**而是**指向**主键值** -- 关键的一句话

![](D:\java\自学笔记\个人总结\2018.11\mysql\innodb 二级索引分布.png)

### innodb和Myisam 保存数据和索引的区别

![](D:\java\自学笔记\个人总结\2018.11\mysql\innodb和Myisam 保存数据和索引的区别.png)

## 覆盖索引

如果一个索引包含了需要查询字段的值

###  好处

+ 索引条目远远小于数据行，只需要读取索引
+ 索引按照列值顺序存储，对于i/p密集的范围查询比随机I/O要快
+ 如myisam 中只缓存索引
+ 由于inodb的聚簇索引，innodb二级索引存储形式有关

无法覆盖索引的原因

1. 没有任何索引能够覆盖查询
2. mysql 不能在索引中执行 like 操作（底层api 限制）

## 使用索引扫描来排序

生成有序结果

1. 排序操作 order by
2. 索引顺序扫描

使用索引扫描**条件**

​	**order by 字句 引用的第一个字段全部为第一个表的时候**

​	**需要满足索引的最左前缀的要求**

### 案例

![](D:\java\自学笔记\个人总结\2018.11\mysql\覆盖索引排序案例1.png)

### 无法使用覆盖索引的案例

![](D:\java\自学笔记\个人总结\2018.11\mysql\无法使用覆盖索引排序的案例.png)



## 压缩（前缀）索引

主要运用是myisam 使用压缩前缀的方式减少索引的大小

默认只压缩字符串

压缩方式：

每次先保存索引块的第一个值，然后将其他值和第一个值比较得到相同前缀的字节数和剩余不同后缀的部分，吧这部分存储即可



## 冗余和重复索引

mysql 允许相同的列上创建多个索引



重复索引是指： 相同的列上按照相同的顺序创建相同累心的索引 **绝对不能出现重复索引！！！**

大多数时间都不需要使用冗余索引，应该尽量扩展已经有的索引而不是创建新的索引



**提升性能的最简单办法就是扩展索引，让索引可以覆盖查询**

1. 使用common_schema 工具查看视图
2. 使用 pt-duplicate-key-cheker 工具，分析表找出冗余和重复索引

## 使用索引的案例：

### 技巧1： 使用 sex in ('m', 't') 来避开需要频繁使用但是不会被访问的某些列

### 技巧2： 避免多个范围条件，将范围条件尽可能留到 where 后面



## 更新索引统计信息

1. records_in_range()， 通过存储引擎传入两个边界或者这个范围大概有多少记录
2. info()  返回各种类型的数据，包括索引和基数

ananlyze table 频率不同引擎不同

1. Memeory 引擎不存储索引统计信息
2. myisam 将索引信心存在磁盘中
3. mysql5.5 版本， innodb 也不在次哦按存储索引统计信息

show index from 查看索引基数

## 减少索引和数据碎片

表的数据存储可能碎片化

+ 行碎片
  + 数据行被存储在多个地方的多个分片
+ 行间碎片
  + 逻辑顺序上的页
+ 剩余空间碎片
  + 值数据页中有大量的空余空间

## 总结

**使用索引查询记住以下几点：**

![](D:\java\自学笔记\个人总结\2018.11\mysql\索引使用技巧.png)

# <font color='red'>查询性能优化,最最最重要的一节</font>

## 慢查询基础：优化数据访问

1. 确认应用程序是否检索了大量超过需要的数据，
2. mysql 服务器 是否在分析大量超过需要的数据行

### 是否向数据库请求了不需要的数据

## 执行查询的基础

![](D:\java\自学笔记\个人总结\2018.11\mysql\执行查询的基础.png)

### 查询状态

使用 `SHOW FULL PROCESSLIST` 命令

+ sleep 
+ Query
+ Locked 
+ Analyzing and statistics 
+ copy to tmp table [on disk]
+ sorting result
+ sending data



#### mysql 客户端/ 服务器通信协议

使用了半双工的通信协议，即只能一端发送数据另一端响应

### 查询缓存





### 查询优化处理

mysql  优化器选择错误的执行计划

+ 统计信息不准确
+ 执行计划中成本估算不等于实际的成本
+ mysql 最优可能和所想不一样
+ Mysql 从不考虑其他并发执行的查询
+ Mysql 并不是任何时候基于成本的优化
+ mysql 不会考虑不受控制的操作的成本
+ 有时候可能无法估算所有可能的执行计划

可以执行的优化类型：

+ 重新定义表的关联顺序
+ 将外连接转为内连接
+ 使用等价变化规则
+ 优化 count() 、min()和max()
+ 预估并转化为常数表达式
+ 覆盖索引扫描
+ 子查询优化
+ 提前终止查询
+ 等值传播
+ 列表 In() 的比较

### 查询执行引擎

### 返回结果给客户端

## mysql 查询优化的局限性

### 关联子查询

### union 的限制

### 索引合并优化

#### 	等值传递

#### 	并行执行

#### 	哈希关联

#### 	松散索引扫描

### 最大值和最小值

### 在同一张表上查询和更新

## 查询优化器的提示

建议直接阅读官方mysql 手册

+ hig_priority 和 low_priority
  + 多个语句同时访问一个表，那些语句优先级相对高一点
+ delayed 
  + 对于 Insert 和 replayce 有效
+ straight_join 
  + 让查询中的所有表按照在语句中出现顺序进行关联
  + 固定前后两个表的关联顺序
+  sql_small_result  和 sql_big_result
  + 只对select 语句有效
  + 优化器对于group by 或者 distinct 查询如何使用两种临时表排序
+ sql_buffer_result
  + 优化器将要吧查询结果放入一个临时表
+ sql_cache 和 sql_no_cache
  + 查询结果集是否应该存在缓存当中
+ sql_calc_found_row5 
  + 严格说并不是一个优化器提示。
  + 让Mysql 返回结果集提供更多的信息
+ for update 和 lock in share mode
  + 提示主要控制 select 语句的锁机制
  + 只对行级锁引擎有效（其实只有innodb  内置支持）
+ use index/ ignor index  / force index 
  + 告诉优化器使用或者不使用哪一些索引
+ optimizer_search_depth
+ optimizer_purne_level
+ optimizer_switch

## 优化特定类型查询

### 优化count() 查询

忽略所有的列而且直接统计所有的行数

#### 简单优化

​	使用总数减去不符合条件的数目即为符合条件的数目

#### 使用近似值

​	



# mysql 高级特性

## 分区表

​	分区对于 sql层来说是一个完全封装底层实现的黑盒子

​	目的： 按照一个比较粗的粒度分在不同的表中

### 下面场景中分区有很大的作用

+ 表非常大以至于无法放到内存当中，
+ 分区表的数据更容易维护
+ 分区表的数据可以分步在不同的物理设备上
+ 使用分区来避免某些特殊的瓶颈
+ 可以备份和回复

### 分区本身也有限制

+ 一个表最多只能有1024个分区（4M）
+ Mysql 5.1 分区表达式必须是整数
+ 如果分区字段有主键或者唯一索引的列，那么所有的主键列和唯一索引都必须包含进来
+ **分区表无法使用外键约束**

## 分区的原理

### SELECT 查询：

​	分区层先打开并锁住所有底层表

。。。。

## 分区表的类型：

## 视图

mysql 5.0 之后引入视图

mysql 处理视图的办法：

+ 合并算法
+ 临时表算法

![](D:\java\自学笔记\个人总结\2018.11\mysql\视图两种算法.png)



### 存储过程和函数

限制

+ 优化器无法使用关键字deterministic 优化单个查询中多次调用存储函数的情况
+ 无法评估存储还书的执行成本
+ 每个连接都有独立的存储过程

### 绑定变量

#### 绑定变量的优化

+ 准备阶段
  + 解析sql , 移除不可能条件，重写子查询
+ 第一次执行
  + 先嘉华嵌套循环的关联（如果可能），将外关联转为内关联
+ 执行sql 语句时候
  + 过滤分区
  + 如果可能，尽量移除count()、min()、max()
  + 移除常数表达式
  + 检测常量表
  + 必要等值传播
  + 分析优化 ref, range 和索引优化等访问数据的方法
  + 优化关联顺序

## 查询缓存

### 查询缓存如何使用内存

![](D:\java\自学笔记\个人总结\2018.11\mysql\查询缓存如何使用内存.png)

### 查询缓存的碎片

![](D:\java\自学笔记\个人总结\2018.11\mysql\查询换承诺中存储查询结果后留下的碎片.png)

### 什么情况下查询缓存能发挥作用

### 如何分析和配置查询缓存

![](D:\java\自学笔记\个人总结\2018.11\mysql\分析和配置查询缓存.png)





# 优化服务器设置

## mysql 配置工作原理

![](D:\java\自学笔记\个人总结\2018.11\mysql\服务器使用.png)

## 语法、作用域、动态性

### 常用变量的修改效果

1. key_buffer_size 
   1. 键缓冲区，分配所有指定的空间
   2. mysql 允许创建多个键缓存
2. table_cahce_size
   1. 会延迟到下次有线程打开表才有效果
   2. 如果值大于缓存中表的数量，线程可以把最新打开的表放入缓存
3. thread_cache_size
   1. 不会立即生效，下次有连接被关闭时候产生效果
   2. 检查缓存中是否有空间缓存线程
4. query_cache_size
   1. 修改之后会立即删除所有缓存的查询，重新分配缓存大小
5. read_buffer_size
   1. 只会在有查询需要使用的时候分配缓存
6. read_rnd_buffer_size
   1. 只会在有查询需要使用的时候分配缓存，只会分配需要内存大小而不是全部大小
7. sort_buffer_size
   1. 只会在查询需要做排序操作时候为该缓存分配内存
   2. 会立即分配该参数指定的大小，而不管排序是否需要
8. 





# 操作系统的硬件优化

## 调优服务器的目标

+ 低延时
  + 需要高速cpu
+ 高吞吐
  + 同时运行很多的查询，一般可以扩展到16个或者24个

## 扩展多个cpu和核心

数据库并发问题

+ 逻辑并发问题
  + 可以看到资源的竞争，如表或者行锁的争用
+ 内部并发问题
  + 比如信号量，访问innoDB 缓冲池页面的资源争用

## 平衡内存和磁盘资源

## 随机I/O和 顺序I/O

顺序读取不能从缓存中受益的原因

+ 一般只需要扫描一次数据
+ 比随机读取快

第二点的原因：

+ 顺序io比随机io快
  + 读取速度要更快
  + 访问内存行的速度也更快
+ 存储引擎执行顺序顺序读比随机读快

**增加内存是解决随机i/o读取最好的办法**

## 缓存 读和写

缓存可以可以延缓写入，但是不能消除读取一样消除写入

事实上，除了上面意外，缓存还允许被集中操作

+ 多次写入，一次刷新
+ I/O合并

## 工作集是什么

## 找到有效的内存/磁盘计划

### 传统磁盘读取数据的过程分为三个步骤

1. 移动读取次哦图到磁盘表面上的正确位置
2. 等待磁盘旋转，等有所需数据在读取磁头下
3. 等待磁盘旋转过去，所有所需数据被读取磁头读出

关键：**访问时间**和**读取速度**

选择磁盘的因素：

+ 存储容量
+ 传输速度
+ 访问时间
+ 主轴转速
+ 物理尺寸

## 固态存储

+ SSD （固态硬盘） 和 PCIE卡

### 高速闪存设备具备：

+ 相比硬盘有更好的随机读写性能
+ 相比硬盘有更好的顺序读写性能
+ 相比硬盘有更好的支持并发功能

## 闪存概述

### 一个设备规格的例子

1. 设备读取性能最高达到 520MB/S
2. 设备写入性能最高达到 480MB/S
3. 持续写入速度可以稳定在420MB/S
4. 每秒可以执行70000 个 4KB 的写操作

## 固态硬盘驱动器(SSD)

X-25E驱动器

## 什么时候应该使用闪存

### 使用 flashcache

数据库下层（至少）有三层

+ INNODB 缓冲池
+ 缓冲池没有命中，就会去flashcache设备去取
+ flashcache设备缓存也没用命中，磁盘上找

## 优化固态存储上的mysql 

改进包括

+ 增加innodb 的 i/o容量
+ 让innodb 日志文件更大
+ 把一些文件从闪存一刀 raid
+ 禁用预读
  + 随机预读
  + 线性预读
+ 配置innodb 刷新算法
  + 建议闪存设备设置 Innodb_flush_neighbor_pages = 0, 避免 Innodb 尝试查找相邻脏页一起刷写
  + 建议设置 Innodb_adaptive_checkpoint 选项为 keep_average, 不要使用默认的 estimate,保证更持续的性能
+ 禁用双写缓存的可能
+ 限制插入缓冲大小

## RAID 性能优化

等级画风

+ RAID 0 
  + 简单的评估成本和性能
  + 没有冗余，不担心数据丢失情况下使用
  + **没有提供任何冗余！！！！！！**
+ RAID 1 
  + 多数情况提供很好的读性能
  + 很好的冗余性
+ RAID 5 
  + 通过分步奇偶校验来吧数据分散到多个磁盘
  + 任意一个盘失效，可以从奇偶校验中重建，但是两个磁盘失效，整个卷无法恢复！！！
  + 用作存放数据或者日志，以读为主的业务
  + 性能最大消耗发生在磁盘失效
+ RAID 10
  + 数据存储的好选择
  + 很好在软件层实现
+ RAID 50
  + 由条带化的 RAID 5 组成，
  + 用处是存放出非常庞大的数据集

### 总结

![](D:\java\自学笔记\个人总结\2018.11\mysql\RAID总结.png)

### RAID 故障转移，迁移和镜像

### RAID 配置和缓存

## SAN 和 NAS

### 应该使用SAN 吗

+ 备份
+ 简化容量规划
+ 存储整合还是服务器整合
+ 高可用
+ 服务器的交互
+ 成本

## 使用多磁盘卷

mysql 创建了多类型文件

+ 数据和索引文件
+ 事务日志文件
+ 二进制日志文件
+ 常规日志
+ 临时文件和临时表

### 使用ext3 

如果使用ext3 或者继承者 ext4, 有是哪个选项控制记录日志，放在 /etc/fstab 作为挂载

+ data = writeback
+ data = ordered
+ data=journal

### 常见文件系统特性总结

![](D:\java\自学笔记\个人总结\2018.11\mysql\常见文件系统特性.png)





# 复制--mysql 关键特性

## 概述

+ 基于行的复制
+ 基于语句的复制

## 复制解决的问题

+ 数据分布
  + 通常不会给宽带造成很大压力
+ 负载均衡
  + 可以将读操作分布到多个服务器上面
+ 数据备份
+ 高可用和故障切换
  + 避免Mysql 单点失败
+ mysql 升级测试

## 复制如何工作

###  mysql 如何复制数据

1. 在主库把数据更改记录到二进制日志中（二进制日志事件）
2. 备库将主库的日志复制到自己的中继日志
3. 备库读取中继日志的时间，将其重放到备库数据之上

![](D:\java\自学笔记\个人总结\2018.11\mysql\复制如何工作.png)



## 配置复制

配置步骤：

1. 在每台服务器上复制账号
2. 配置主库和备库
3. 通知备库连接到主库从主库复制数据

### 创建复制账号

Mysql 会赋予一些特殊权限给复制线程

通过以下语句创建用户账号

![](D:\java\自学笔记\个人总结\2018.11\mysql\创建复制账号.png)

> 复制账号事实上只需要主库的 replication slave 权限
>
> 为什么需要备库也拥有同样的权限呢
>
> 1. 监控和管理复制账号需要 replication client 权限
> 2. 如果在主库上创建了账号，从主库将数据克隆岛备库时候，备库也设置好了。变成主库需要配置。
> 3. 简单来说：**方便主备库角色的切换**

### 配置主库和备库

打开主库二进制日志，指定一个独一无二的服务器id 

**在主库的my.cnf 文件当中增加或者修改如下内容**

```
log_bin = mysql-bin
server_id = 10
```

**必须指定一个唯一的服务器id**

#### 查看二进制日志文件是否在主库上创建，使用`show master status`

#### 备库添加类似配置

```
log_bin = mysql_bin
server_id = 2
relay_log = /var/lib/mysql/mysql-relay-bin
log_slave_updates = 1
read_only = 1
```

### 启动复制

下面是复制开始的基本命令

![](D:\java\自学笔记\个人总结\2018.11\mysql\复制开始.png)

#### 开始复制

`start slave`

#### 没有错误使用 `show slave status\G`检查配置

### 从另一个服务器开始复制

下面三个条件来让主库和备库保持同步：

+ 某个时间点的主库的数据快照
+ 主库当前的二进制日志文件，和或者数据快照在该二进制日志文件中的偏移量，我们吧这两个值为日志为日志文件坐标，可以通过`show master status` 命令来获取这些值
+ 从快照到现在的二进制日志

从别的服务器克隆备库的方法

+ 使用冷备份
  + 关闭主库，吧数据复制到备库，重启主库之后会有一个新的二进制文件，然后备库执行 change master to  执行这个文件起始处，
  + 缺点：需要关闭主库
+ 使用热备份
  + 如果仅仅使用myisam 表， 主库运行时使用mysqlhotcopy 或者 rsync 复制数据
+ 使用mysqldump
  + 如果只包含innodb 表， 使用一下命令来转储主库数据并将其加载到备库
  + ![](D:\java\自学笔记\个人总结\2018.11\mysql\使用mysqldump.png)
+ 使用快照或者备份
  + 只要知道对应二进制日志坐标，就可以使用主库的快照或者备份初始化备库
+ 使用percona Xtrabackup

  + 是一款开源的热备份工具
  + 如果是从主库获得备份，可以从 xtrabackup
+ 使用另外的备份

### 推荐的复制配置

主库二进制日志最重要的选项

sync_binlog = 1

开启之后，每次提交事务之前将二进制日志同步到磁盘上

#### 使用Innodb 推荐的复制配置

![](D:\java\自学笔记\个人总结\2018.11\mysql\使用Innodb推荐复制配置.png)

## 复制的原理（重要）

### 基于语句的复制

msyql5.0 之前只支持基于语句的复制

### 基于行的复制

mysql 5.1 之后支持

### 对比区别：

理论上基于行的复制整体更优，而且实际应用也是用与基于行的复制

+ 基于语句复制的优点
  + 主备模式不同时候，逻辑复制可以多种情况工作
  + 基本就是执行sql 语句，出现问题可以很好的定位错误
+ 基于语句复制的缺点
  + 如果使用触发器或者存储过程，不要使用基于语句模式复制，会有大量的bug,除非清楚不会碰到问题
+ 基于行复制的优点
  + 能处理几乎所有的场景，基本不会出现bug
  + 可以减少锁的使用，因为它并不要求这种强串行化是可以重复的
  + 占用更少的sql
  + 更快找到并解决数据不一致的情况
+ 基于行复制的缺点
  + 无法判断执行的sql
  + 出现问题很难定位错误
  + 无法处理在备库修改表的schema这种情况
  + 某些情况下，如找不到修改行时候，可能导致复制停止



## 复制文件

1. mysql0bin.index ：没有此文件msyql 识别不了二进制日志文件
2. mysql-relay-bin-index ：中继日志的索引文件
3. master.info ：保存备库连接到主库所需要的信息（纯文本格式），**不能删除，否则备库重启后无法连接到主库**（<font color='red'>保存着密码，需要严格权限控制</font>）
4. relay-log.info ： 包含了当前备库复制二进制日志和中继日志的坐标

## 发送复制文件到其他备库

![](D:\java\自学笔记\个人总结\2018.11\mysql\发送复制文件到其他备库.png)

### 复制过滤器

![](D:\java\自学笔记\个人总结\2018.11\mysql\复制过滤选项.png)



## 复制拓扑

基本原则：

+ 一个mysql 备库实例只能有一个主库
+ 每个备库必须要有唯一服务器id
+ 一个主库可以有多个备库
+ 如果打开了 log_slave_updates 选项， 一个备库可以吧主库的数据变化传播到备库



## 一主多备库

### 主动-主动模式下的主-主复制

### 主动-被动模式下的主-主复制

如何配置主-主服务器对，在两台服务器执行对称后，使其拥有相同的配置

+ 确保两台服务器数据相同
+ 启用二进制日志，选择唯一服务器id, 创建账号
+ **启用备库更新日志记录（故障转移和恢复的关键）**
+ 被动服务器设置成只读，防止可能与主服务器上的更新产生冲突（可选）
+ 启动每个服务器mysql 实例
+ 将每个主库设置为对方的备库，使用新创建的二进制日志文件进行运行

### 拥有备库的主- 主结构

增加了冗余，可以消除站点单点失效的问题

### 环形复制

![](D:\java\自学笔记\个人总结\2018.11\mysql\环形复制.png)

### 主库、分发主库以及备库

### 模拟多主库复制

![](D:\java\自学笔记\个人总结\2018.11\mysql\模拟多主库复制.png)

#### 另一种方式

![](D:\java\自学笔记\个人总结\2018.11\mysql\模拟多主库复制另一种.png)

### 为什么使用日志服务器比用 mysqlbinlog 来实现恢复更好

![](D:\java\自学笔记\个人总结\2018.11\mysql\为什么使用日志服务器更好.png)

## 复制和容量计划

假设工作负载为20%的写和 80%的读， 为了计算简单，假设有如下条件

+ 读和写查询包含同样的工作量
+ 所有服务器等同，每秒能进行100次查询
+ 备库和主库有同样的性能特征
+ 所有读操作转移到备库

## 为什么无法扩展写操作

## 复制管理和维护

### 监控复制

### 测试备库延迟

![](D:\java\自学笔记\个人总结\2018.11\mysql\测试备库.png)

### 确认主备是否一致

### 从主库重新同步到备库

## 在一个主-主配置中交换角色

## 数据会损坏或者丢失的错误

+ 主库意外关闭
+ 备库意外关闭

### 由于msyql 非常关闭产生的常见情况

+ 主库上的二进制日志损坏
+ 备库的中级日志损坏
+ 二进制日志与Innodb 事务日志不同步

### 二进制日志损坏时候，能恢复多少数据取决于损坏的类型

+ 数据改变，但事件仍然是有效的sql 
+ 数据改变并且事件是无效的sql
+ 数据泄露并且（或者）事件长度是错误的
+ 某些事件已经损坏或者被覆盖，或者偏移量已经改变并且下一个事件的起始偏移量也是错误的

### 使用非事务性表

### 非事务性表和混合事务性

### 不确定的语句

### 主库和备库使用不同的存储引擎

### 备库发生数据改变

### 不是唯一的服务器ID

### 未定义的服务器Id

### 对未复制数据的依赖性

### 不复制所有的更新

### innodb 加锁导致锁争用



## 其他复制技术

### SPARK Tungsten : java编写的开源中间件复制产品 

+ #### ![](D:\java\自学笔记\个人总结\2018.11\mysql\Tungsten有点.png),,,,缺点如下,,![](D:\java\自学笔记\个人总结\2018.11\mysql\tunsten缺点.png)





# 可扩展的mysql

# 高可用性

## 如何实现高可用性

+ 尝试避免导致宕机的原因来减少宕机时间

+ 尽量保证发生宕机后能在快速回复

### 提升平均失效时间

![](D:\java\自学笔记\个人总结\2018.11\mysql\提升失效时间.png)

### 降低平均恢复时间

## 避免单点失效

系统增加冗余：

+ 增加空余容量
+ 重复组件

## 共同存储或者磁盘复制

优点：

+ 避免除了存储之外的其他任何组件失效引起数据丢失
+ 有助于减少系统一些部分的可用性需求
+ （但是SAN 本身失效则全部失效）